## 网页开发学习笔记

脚本调用策略小结：

- 如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 `async`。
- 如果脚本需要等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 `defer`，将关联的脚本按所需顺序置于 HTML 中。

[进度](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Return_values)

### JavaScript一些代码规范和特性

1. 声明变量尽可能使用`let`。

2. 变量命名遵循小写驼峰命名规范。

3. 字符串使用单引号`'`或双引号`"`包裹。

4. 变量不需要标注类型。

5. 布尔类型的两个值为`true`和`false`。

6. 相等比较符为`===`，不等比较符为`!==`。

7. 数组的定义为`let myNameArray = ['Chris', 'Bob', 'Jim'];`

8. 类型的定义为`let dog = { name : 'Spot', breed : 'Dalmatian' };`

9. 获取一个变量的类型`type of myNameArray`

10. JavaScript中只有一种数字类型：`number`。

11. 转义字符使用`\`。

12. 字符串+数字会自动将数字转为字符串并连接。

13. 将字符串转为数字，通过`Number()`函数。

14. 将数字转为字符串，通过`toString()`方法。

15. 字符串中提取子串位置，通过`indexOf()`方法。

16. 字符串提取子串，通过`slice(,)`方法（左闭右开）。

17. 字符串中提取剩余子串，通过`slice()`方法。（传入起始位置）

18. 将所有字母转为大写或小写：通过`toLowerCase()`和`toUpperCase()`方法。

19. 字符串中替换某部分，通过`replace('','')`方法。

20. 数组中的元素类型可以不同，甚至嵌套：`let random = ['tree', 795, [0, 1, 2]];`

21. 字符串的`split()`方法可以返回一个子串数组。

22. 数组的`join()`方法可以将多个子串拼接起来。

23. 在数组末尾添加或删除元素，使用`push()`和`pop()`方法，`push()`返回新数组的长度，`pop()`返回删除的元素。

24. 如果要在数组的开头进行添加或删除元素操作，则可以使用`unshift()`和`shift()`方法。

25. 任何不是`false`、`undefined`、`null`、`0`、`NaN`或`''`的值作为判断条件都会返回`true`。

26. `switch`语句的每一项结束之后，需要一个`break`语句；`default`项之后可以不加。

27. 函数定义：`function draw() {}`，返回值通过`return`返回。

28. 匿名函数：`function(){}`，匿名函数可以绑定到变量上。

29. 匿名函数也称为函数表达式，函数声明会进行声明提升（declaration hoisting），而函数表达式不会。

30. 匿名函数支持lambda表达式：`()=>{...}`

31. 多个js文件中定义相同签名的函数，只会默认调用第一个导入的js文件中的函数。

32. 多个js文件共享作用域，因此同名变量的重声明会出现错误。

33. web中，**事件**在浏览器窗口中被触发并且通常被绑定到窗口内部的特定部分（元素、一系列元素、HTML代码或是整个浏览器窗口）。常见的事件有：
    
    - 在某个元素上点击鼠标或悬停光标
    
    - 在键盘中按下某个按键
    
    - 调整浏览器的大小或者关闭浏览器窗口
    
    - 网页停止加载
    
    - 提交表单
    
    - 播放、暂停、关闭视频
    
    - 发生错误
    
    - [Event reference | MDN](https://developer.mozilla.org/en-US/docs/Web/Events)

34. 每个可用的事件都有一个相应的**事件处理器**，在事件触发时运行。当定义了一个响应事件的代码块时，称为**注册了一个事件处理器**。**事件处理器**有时也被称为**事件监听器**。

35. 网页开发中，不要混用HTML和JavaScript（不要在HTML中写JavaScript）。

36. 另一种实现事件监听的方法是使用`addEventListener`和`removeEventListener`。好处是可以灵活地注册和注销监听器，也可以同时触发多个函数。

37. 事件处理函数会接收到一个**事件对象**，它是事件所发生的元素的引用。可以通过事件对象获取额外的信息。一般在响应函数中接收这个参数：`btn.onclick = function(e){...}`

38. 当一个事件发生在具有父元素的元素上时，浏览器有两个不同的阶段：捕获阶段和冒泡阶段。
    
    - 捕获阶段：1.浏览器检查元素的最外层祖先是否在捕获阶段中注册了事件处理程序，如果是，则运行它；2.之后，移动到下一级祖先元素，执行相同的操作，直到实际触发的元素。
    
    - 冒泡阶段：1.浏览器检查实际触发的元素是否在冒泡阶段中注册了事件处理程序，如果是，则运行它；2.之后，移动到上一级祖先元素，执行相同的操作，直到最外层祖先。（与捕获阶段相反）
    
    - 现代浏览器在默认情况下，按照**冒泡阶段**进行事件注册。

39. 当不期望事件沿着冒泡链向上传播时，可以通过`stopPropagation()`终止事件传播：
    
    ```javascript
    video.onclick = function(e) {
      e.stopPropagation();
      video.play();
    };
    ```

40. 可以通过大括号`{}`嵌套的方式，在对象成员中创造子命名空间：
    
    ```javascript
    name : {
        first : 'Bob',
        last : 'Smith'
    },
    ```

41. 既可以通过传统的**点表示法**访问子元素，也可以通过**括号表示法**访问：
    
    ```javascript
    person.age
    person.name.first
    
    person['age']
    person['name']['first']
    ```

42. 不仅可以设置对象成员的值，也可以通过赋值方式创建新的成员。

43. **括号表示法**可以用来创建新的成员：
    
    ```javascript
    person[myDataName] = myDataValue
    ```

44. 对象内部可以通过`this`关键字获取到当前对象。

45. 类的声明使用`class`关键字，类中的方法**不需要**函数关键字`function`。构造器使用关键字`constructor`声明，它会创建一个新的对象，并将`this`绑定到这个新的对象，执行其中代码之后返回这个新的对象。有了构造器之后，外部代码可以通过`new`关键字和类名来调用类构造器产生对象。构造器也可以默认生成。

46. 类之间的继承通过关键字`extends`实现。父类可以通过关键字`super`访问。子类的构造函数中需要先通过`super()`调用父类的构造函数。

47. 在成员前面标记`#`，则成员变成私有数据（函数），无法从外部访问。

48. JSON中的字符串、属性名称周围必须使用引号，且只能使用双引号`"`，单引号无效。

49. JSON中只包含属性，没有方法（纯数据格式）。

50. web中，如果需要将字符串数据转为解析为json，可以使用`JSON.parse()`实现。如果想要将json转为字符串数据，则可以使用`JSON.stringify()`。

51. 通过`fetch`可以获取目标资源地址的异步`promise`对象。该对象的`state`属性为`pending`，意味着操作正在进行中。

52. `promise`对象的`then()`方法中可以传递进操作成功时需要处理的函数。

53. `promise`可以在`then()`方法中完成嵌套调用。

54. 由于`then()`方法也会返回`promise`，因此可以通过点操作符链式调用（推荐）：
    
    ```javascript
    fetchPromise
      .then( response => {
        return response.json();
      })
      .then( json => {
        console.log(json[0].name);
      });
    ```

55. `promise`可以通过方法`catch()`来不会异步调用中产生的错误。

56. `promise`一共有三种状态：
    
    - pending：待定状态，表示正在进行中；
    
    - fulfilled：已兑现，表示操作成功，`then()`方法被调用；
    
    - rejected：已拒绝，表示操作失败，`catch()`方法被调用；

57. 有时会用`settled`来表示`promise`处于`fulfilled`或`rejected`。

58. `Promise.all()`方法接收一个Promise数组，返回一个单一的Promise：
    
    - 当且仅当数组中所有的Promise都被兑现时，才会通知`then()`，并提供一个包含所有响应的数组，数组中响应的顺序与传入`all()`的Promise的顺序相同。
    
    - 如果数组中有任何一个Promise被拒绝，则`catch()`，并提供该拒绝的Promise所抛出的错误。

59. `Promise.any()`方法接收一个Promise数组，在任意一个Promise被兑现时，调用`then()`，都被拒绝时才调用`catch()`。

60. 在函数签名`function`之前添加异步关键字`async`，可以使该函数成为**异步函数**。

61. 在异步函数中，可以使用返回Promise的函数前使用`await`关键字，这使得代码在该处阻塞直到获取返回值或者抛出错误：
    
    ```typescript
    async function fetchProducts() {
        try {
            const response = await fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');
            if (!response.ok) {
                 throw new Error('HTTP request error: ${response.status}');
            }
            const json = await response.json();
            console.log(json[0].name);
        }
        catch(error) {
            console.error('Cannot get product list: ${error}');
        }
    }
    ```

62. 异步函数总是返回一个`Promise`，所以需要像处理`Promise`一样处理异步函数的返回值。